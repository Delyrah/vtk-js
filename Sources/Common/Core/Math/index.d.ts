export function radiansFromDegrees(deg: any): number;
export function degreesFromRadians(rad: any): number;
export function arrayMin(arr: any, offset?: number, stride?: number): number;
export function arrayMax(arr: any, offset?: number, stride?: number): number;
export function arrayRange(arr: any, offset?: number, stride?: number): number[];
export function nearestPowerOfTwo(xi: any): number;
export function isPowerOfTwo(x: any): boolean;
export function binomial(m: any, n: any): number;
export function beginCombination(m: any, n: any): number[] | 0;
export function nextCombination(m: any, n: any, r: any): number;
export function randomSeed(seed: any): void;
export function getSeed(): number;
export function random(minValue?: number, maxValue?: number): number;
export function add(a: any, b: any, out: any): void;
export function subtract(a: any, b: any, out: any): void;
export function multiplyScalar(vec: any, scalar: any): void;
export function multiplyScalar2D(vec: any, scalar: any): void;
export function dot(x: any, y: any): number;
export function outer(x: any, y: any, out_3x3: any): void;
export function cross(x: any, y: any, out: any): void;
export function norm(x: any, n?: number): number;
export function normalize(x: any): number;
export function perpendiculars(x: any, y: any, z: any, theta: any): void;
export function projectVector(a: any, b: any, projection: any): boolean;
export function dot2D(x: any, y: any): number;
export function projectVector2D(a: any, b: any, projection: any): boolean;
export function distance2BetweenPoints(x: any, y: any): number;
export function angleBetweenVectors(v1: any, v2: any): number;
export function gaussianAmplitude(mean: any, variance: any, position: any): number;
export function gaussianWeight(mean: any, variance: any, position: any): number;
export function outer2D(x: any, y: any, out_2x2: any): void;
export function norm2D(x2D: any): number;
export function normalize2D(x: any): number;
export function determinant2x2(...args: any[]): number;
export function LUFactor3x3(mat_3x3: any, index_3: any): void;
export function LUSolve3x3(mat_3x3: any, index_3: any, x_3: any): void;
export function linearSolve3x3(mat_3x3: any, x_3: any, y_3: any): void;
export function multiply3x3_vect3(mat_3x3: any, in_3: any, out_3: any): void;
export function multiply3x3_mat3(a_3x3: any, b_3x3: any, out_3x3: any): void;
export function multiplyMatrix(a: any, b: any, rowA: any, colA: any, rowB: any, colB: any, out_rowXcol: any): void;
export function transpose3x3(in_3x3: any, outT_3x3: any): void;
export function invert3x3(in_3x3: any, outI_3x3: any): void;
export function identity3x3(mat_3x3: any): void;
export function determinant3x3(mat_3x3: any): number;
export function quaternionToMatrix3x3(quat_4: any, mat_3x3: any): void;
export function areMatricesEqual(matA: any, matB: any): any;
export function jacobiN(a: any, n: any, w: any, v: any): 1 | 0;
export function matrix3x3ToQuaternion(mat_3x3: any, quat_4: any): void;
export function multiplyQuaternion(quat_1: any, quat_2: any, quat_out: any): void;
export function orthogonalize3x3(a_3x3: any, out_3x3: any): void;
export function diagonalize3x3(a_3x3: any, w_3: any, v_3x3: any): void;
export function singularValueDecomposition3x3(a_3x3: any, u_3x3: any, w_3: any, vT_3x3: any): void;
export function luFactorLinearSystem(A: any, index: any, size: any): 1 | 0;
export function luSolveLinearSystem(A: any, index: any, x: any, size: any): void;
export function solveLinearSystem(A: any, x: any, size: any): 1 | 0;
export function invertMatrix(A: any, AI: any, size: any, index?: any, column?: any): 1 | 0;
export function estimateMatrixCondition(A: any, size: any): number;
export function jacobi(a_3x3: any, w: any, v: any): 1 | 0;
export function solveHomogeneousLeastSquares(numberOfSamples: any, xt: any, xOrder: any, mt: any): 1 | 0;
export function solveLeastSquares(numberOfSamples: any, xt: any, xOrder: any, yt: any, yOrder: any, mt: any, checkHomogeneous?: boolean): 0 | 1;
export function hex2float(hexStr: any, outFloatArray?: number[]): number[];
export function rgb2hsv(rgb: any, hsv: any): void;
export function hsv2rgb(hsv: any, rgb: any): void;
export function lab2xyz(lab: any, xyz: any): void;
export function xyz2lab(xyz: any, lab: any): void;
export function xyz2rgb(xyz: any, rgb: any): void;
export function rgb2xyz(rgb: any, xyz: any): void;
export function rgb2lab(rgb: any, lab: any): void;
export function lab2rgb(lab: any, rgb: any): void;
export function uninitializeBounds(bounds: any): void;
export function areBoundsInitialized(bounds: any): boolean;
export function computeBoundsFromPoints(point1: any, point2: any, bounds: any): void;
export function clampValue(value: any, minValue: any, maxValue: any): any;
export function clampVector(vector: any, minVector: any, maxVector: any, out?: any[]): any[];
export function roundVector(vector: any, out?: any[]): any[];
export function clampAndNormalizeValue(value: any, range: any): number;
export function extentIsWithinOtherExtent(extent1: any, extent2: any): 1 | 0;
export function boundsIsWithinOtherBounds(bounds1_6: any, bounds2_6: any, delta_3: any): 1 | 0;
export function pointIsWithinBounds(point_3: any, bounds_6: any, delta_3: any): 1 | 0;
export function solve3PointCircle(p1: any, p2: any, p3: any, center: any): number;
export function createUninitializedBounds(): any[];
export function getMajorAxisIndex(vector: any): number;
export function floatToHex2(value: any): string;
export function floatRGB2HexCode(rgbArray: any, prefix?: string): string;
export function float2CssRGBA(rgbArray: any): string;
export function Pi(): number;
export const round: (x: number) => number;
export const floor: (x: number) => number;
export const ceil: (x: number) => number;
export const min: (...values: number[]) => number;
export const max: (...values: number[]) => number;
export function ceilLog2(): any;
export function factorial(): any;
export function gaussian(): any;
export function getScalarTypeFittingRange(): any;
export function getAdjustedScalarRange(): any;
export const inf: number;
export const negInf: number;
export function isInf(value: any): boolean;
export const isFinite: any;
export const isNaN: any;
export const isNan: any;
declare namespace _default {
    export { Pi };
    export { radiansFromDegrees };
    export { degreesFromRadians };
    export { round };
    export { floor };
    export { ceil };
    export { ceilLog2 };
    export { min };
    export { max };
    export { arrayMin };
    export { arrayMax };
    export { arrayRange };
    export { isPowerOfTwo };
    export { nearestPowerOfTwo };
    export { factorial };
    export { binomial };
    export { beginCombination };
    export { nextCombination };
    export { randomSeed };
    export { getSeed };
    export { random };
    export { gaussian };
    export { add };
    export { subtract };
    export { multiplyScalar };
    export { multiplyScalar2D };
    export { dot };
    export { outer };
    export { cross };
    export { norm };
    export { normalize };
    export { perpendiculars };
    export { projectVector };
    export { projectVector2D };
    export { distance2BetweenPoints };
    export { angleBetweenVectors };
    export { gaussianAmplitude };
    export { gaussianWeight };
    export { dot2D };
    export { outer2D };
    export { norm2D };
    export { normalize2D };
    export { determinant2x2 };
    export { LUFactor3x3 };
    export { LUSolve3x3 };
    export { linearSolve3x3 };
    export { multiply3x3_vect3 };
    export { multiply3x3_mat3 };
    export { multiplyMatrix };
    export { transpose3x3 };
    export { invert3x3 };
    export { identity3x3 };
    export { determinant3x3 };
    export { quaternionToMatrix3x3 };
    export { areMatricesEqual };
    export { matrix3x3ToQuaternion };
    export { multiplyQuaternion };
    export { orthogonalize3x3 };
    export { diagonalize3x3 };
    export { singularValueDecomposition3x3 };
    export { solveLinearSystem };
    export { invertMatrix };
    export { luFactorLinearSystem };
    export { luSolveLinearSystem };
    export { estimateMatrixCondition };
    export { jacobi };
    export { jacobiN };
    export { solveHomogeneousLeastSquares };
    export { solveLeastSquares };
    export { hex2float };
    export { rgb2hsv };
    export { hsv2rgb };
    export { lab2xyz };
    export { xyz2lab };
    export { xyz2rgb };
    export { rgb2xyz };
    export { rgb2lab };
    export { lab2rgb };
    export { uninitializeBounds };
    export { areBoundsInitialized };
    export { computeBoundsFromPoints };
    export { clampValue };
    export { clampVector };
    export { clampAndNormalizeValue };
    export { getScalarTypeFittingRange };
    export { getAdjustedScalarRange };
    export { extentIsWithinOtherExtent };
    export { boundsIsWithinOtherBounds };
    export { pointIsWithinBounds };
    export { solve3PointCircle };
    export { inf };
    export { negInf };
    export { isInf };
    export { isNaN as isNan };
    export { isNaN };
    export { isFinite };
    export { createUninitializedBounds };
    export { getMajorAxisIndex };
    export { floatToHex2 };
    export { floatRGB2HexCode };
    export { float2CssRGBA };
}
export default _default;
